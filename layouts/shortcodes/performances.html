{{/* vim:set sw=2 ts=2 sts=2 expandtab: */}}
{{- $future := true -}}
{{- $past := true -}}
{{- if or (.Get "future") (.Get "past") -}}
{{- if .Get "future" -}}
{{- $future = true -}}
{{- else -}}
{{- $future = false -}}
{{- end -}}
{{- if .Get "past" -}}
{{- $past = true -}}
{{- else -}}
{{- $past = false -}}
{{- end -}}
{{- end -}}

{{- if $future -}}
<hr />
<div id="future-events"></div>
{{- end }}
{{ if $past -}}
<hr />
<div id="past-events"></div>
{{- end }}

<!-- Create the JSON structure -->

<script>
// What a wonderful feature of Hugo to automatically serialize into
// JSON!
var performancesList = {{ $.Site.Data.performances | jsonify (dict "indent" "  ") | safeJS }};
var projectsList = {{ $.Site.Data.projects | jsonify (dict "indent" "  ") | safeJS }};
var simplePast = {{ if .Get "simple_past" }}true{{ else }}false{{ end }};

// TODO: Move this to a separate file.

// This class represents a template.
class PrettyEvents {
  #eventList;
  #parentObj;
  #isFuture;
  constructor(eventList, parentObj, isFuture) {
    this.#eventList = eventList;
    this.#parentObj = parentObj;
    this.#isFuture = isFuture;
  }

  // Make a DOM element representing the event.
  eventElement(ev) {
    var evP = document.createElement('p');
    var aboveEvent = document.createElement('small');
    evP.appendChild(aboveEvent);
    const options = {
      'year': 'numeric',
      'month': 'short',
      'day': 'numeric',
      'hour': 'numeric',
    };

    var evDate = document.createTextNode(
      ev["start_time_ts"].toLocaleString(undefined, options)
    );
    aboveEvent.appendChild(A(evDate, ev['url']));
    if (ev['tickets'] && this.#isFuture) {
      var tickets = document.createTextNode("ðŸŽ« tickets");
      addText(aboveEvent, " ");
      aboveEvent.appendChild(A(tickets, ev['tickets']))
    }
    evP.appendChild(document.createElement('br'));
    var evTitle = document.createElement('strong');
    if (this.#isFuture) {
      addText(evTitle, 'ðŸŽµ ');
    } else {
      addText(evTitle, 'âœ”ï¸ ');
    }
    evTitle.appendChild(document.createTextNode(ev['name']));
    evP.appendChild(evTitle);
    if (ev['instrument']) {
      if (this.#isFuture) {
        evP.appendChild(document.createTextNode(" â€“ will play "));
      } else {
        evP.appendChild(document.createTextNode(" â€“ played "));
      }
      evP.appendChild(document.createTextNode(ev['instrument']));
    }
    if (ev['with'].length) {
      evP.appendChild(document.createTextNode(" with "));
      evP.appendChild(document.createTextNode(joinList(ev['with'], ", ", " and ")));
    }
    if (ev['venue']) {
      evP.appendChild(document.createTextNode(" in "));
      var venue = document.createTextNode(ev['venue']);
      evP.appendChild(A(venue, ev['venue_url']));
    }
    if (ev['description'] && this.#isFuture) {
      evP.appendChild(document.createTextNode(' - '));
      evP.appendChild(document.createTextNode(ev['description']));
    } else {
      addText(evP, ".");
    }

    // The enclosing div. (Maybe unnecessary?)
    var evDiv = document.createElement('div');
    evDiv.setAttribute('class', 'event');
    evDiv.appendChild(evP);
    return evDiv;
  }

  populate() {
    this.#eventList.forEach((ev) => this.#parentObj.appendChild(this.eventElement(ev)));
  }
}

// This class represents a template.
class CompactEvents {
  #eventList;
  #parentObj;
  #isFuture;
  constructor(eventList, parentObj, title, headerID, isFuture) {
    this.#eventList = eventList;
    this.#parentObj = parentObj;
    this.#isFuture = isFuture;
  }

  // Make a DOM element representing the event.
  eventElement(ev) {
    var li = document.createElement('li');
    var ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    li.appendChild(ul);

    const optionsFuture = {
      'year': 'numeric',
      'month': 'short',
      'day': 'numeric',
      'hour': 'numeric',
    };
    const optionsPast = {
      'year': 'numeric',
      'month': 'short',
      'day': 'numeric',
    };

    function labelItem(label, ...children) {
      var item = document.createElement('li');
      item.appendChild(document.createTextNode(label));
      children.forEach(c => item.appendChild(c));
      return item;
    }

    // Resolve project and display name
    var proj = ev['project'] ? projectsList[ev['project']] : null;
    var displayName = ev['name'] || (proj ? proj['name'] : '');
    var nameInferredFromProject = !ev['name'] && proj;

    // Event name (only if there is one)
    if (displayName) {
      ul.appendChild(labelItem("Event name: ", document.createTextNode(displayName)));
    }

    // Project link (skip when name was inferred from project to avoid redundancy)
    if (proj && ev['name']) {
      var projLink = A(document.createTextNode(proj['name']), '/music/projects/' + ev['project'] + '/');
      ul.appendChild(labelItem("Project: ", projLink));
    }

    // Date
    var dateText = ev["start_time_ts"].toLocaleString(undefined, this.#isFuture ? optionsFuture : optionsPast);
    var dateNode = document.createTextNode(dateText);
    if (ev['tickets'] && this.#isFuture) {
      var ticketLink = A(document.createTextNode("ðŸŽ« tickets"), ev['tickets']);
      ul.appendChild(labelItem("Date: ", dateNode, document.createTextNode(" "), ticketLink));
    } else {
      ul.appendChild(labelItem("Date: ", dateNode));
    }

    // Venue
    if (ev['venue']) {
      ul.appendChild(labelItem("Venue: ", A(document.createTextNode(ev['venue']), ev['venue_url'])));
    }

    // Involvement
    if (ev['instrument']) {
      ul.appendChild(labelItem("Played ", document.createTextNode(ev['instrument'])));
    }

    // With
    if (ev['with'] && ev['with'].length) {
      ul.appendChild(labelItem("With: ", document.createTextNode(joinList(ev['with'], ", ", " and "))));
    }

    // Description
    if (ev['description']) {
      ul.appendChild(labelItem("Description: ", document.createTextNode(ev['description'])));
    }

    // Link
    if (ev['url']) {
      var small = document.createElement('small');
      small.appendChild(A(document.createTextNode(ev['url']), ev['url']));
      ul.appendChild(labelItem("Link: ", small));
    }

    return li;
  }

  populate() {
    var ol = document.createElement('ol');
    this.#eventList.forEach((ev) => ol.appendChild(this.eventElement(ev)));
    this.#parentObj.appendChild(ol);
  }
}

// Simple tabular view: date | event name | venue
class SimpleEvents {
  #eventList;
  #parentObj;
  constructor(eventList, parentObj) {
    this.#eventList = eventList;
    this.#parentObj = parentObj;
  }

  populate() {
    var table = document.createElement('table');
    table.setAttribute('class', 'performances-simple-table');
    var tbody = document.createElement('tbody');
    table.appendChild(tbody);
    const opts = { 'year': 'numeric', 'month': 'short', 'day': 'numeric' };
    this.#eventList.forEach((ev) => {
      var proj = ev['project'] ? projectsList[ev['project']] : null;
      var displayName = ev['name'] || (proj ? proj['name'] : '');

      var tr = document.createElement('tr');

      var tdDate = document.createElement('td');
      tdDate.setAttribute('class', 'perf-date');
      tdDate.appendChild(document.createTextNode(ev['start_time_ts'].toLocaleString(undefined, opts)));
      tr.appendChild(tdDate);

      var tdName = document.createElement('td');
      tdName.setAttribute('class', 'perf-name');
      if (displayName) { tdName.appendChild(document.createTextNode(displayName)); }
      tr.appendChild(tdName);

      var tdVenue = document.createElement('td');
      tdVenue.setAttribute('class', 'perf-venue');
      if (ev['venue']) { tdVenue.appendChild(A(document.createTextNode(ev['venue']), ev['venue_url'])); }
      tr.appendChild(tdVenue);

      tbody.appendChild(tr);
    });
    this.#parentObj.appendChild(table);
  }
}

function joinList(lst, first_delim, second_delim) {
  if (lst.length == 0) {
    return "";
  } else if (lst.length == 1) {
    return lst[0];
  }
  var result = "";
  for (i = 0; i < lst.length; i++) {
    if (i == (lst.length - 1)) {
      // Last element
      result = result + second_delim + lst[i];
    } else {
      result = result + lst[i];
      if (i != (lst.length - 2) || lst.length > 2) {
        result = result + first_delim;
      }
    }
  }
  return result;
}

function A(elem, url) {
  if (!url) {
    return elem;
  }
  var a = document.createElement('a');
  a.setAttribute('href', url);
  a.appendChild(elem);
  return a;
}

function addText(elem, txt) {
  elem.appendChild(document.createTextNode(txt));
}

function populatePerformances() {
  var futureEventsDiv = document.getElementById("future-events");
  var pastEventsDiv = document.getElementById("past-events");

  // Proof of concept for page updates.
  var pastEvents = [];
  var futureEvents = [];
  const now = new Date();
  for (i in performancesList) {
    var ev = performancesList[i];
    if (ev['name'] == "end_marker") {
      // Don't use this element.
      break;
    }
    if (ev['start_time']) {
      var d = new Date(Date.parse(ev['start_time']));
      ev['start_time_ts'] = d;
      if (ev['start_time_ts'].getTime() > now.getTime()) {
        futureEvents.push(ev);
      } else {
        pastEvents.push(ev);
      }
    } else {
      console.log("Event " + ev['name'] + " is missing start_time");
    }
  }
  // Sort events by date.
  futureEvents.sort(function(a, b) {
    // Reverse chronological.
    if (a['start_time_ts'].getTime() > b['start_time_ts'].getTime()) {
      return 1;
    } else {
      return -1;
    }
  });
  pastEvents.sort(function(a, b) {
    // Chronological.
    if (a['start_time_ts'].getTime() < b['start_time_ts'].getTime()) {
      return -1;
    } else {
      return 1;
    }
  });

  if (futureEvents.length > 0) {
    var hdr = document.createElement('h2');
    hdr.setAttribute('id', 'future-performances');
    hdr.appendChild(document.createTextNode('Upcoming Performances'));
    futureEventsDiv.appendChild(hdr);
    var tmpl = new PrettyEvents(futureEvents, futureEventsDiv, true);
    tmpl.populate();
  }
  if (pastEvents.length > 0) {
    var hdr = document.createElement('h2');
    hdr.setAttribute('id', 'past-performances');
    hdr.appendChild(document.createTextNode("Past Performances"));
    pastEventsDiv.appendChild(hdr);
    if (simplePast) {
      var tmpl = new SimpleEvents(pastEvents, pastEventsDiv);
      tmpl.populate();
    } else {
      var tmpl = new CompactEvents(pastEvents, pastEventsDiv, false);
      tmpl.populate();
    }
  }
}

window.addEventListener('load', (event) => {
  populatePerformances();
});
</script>
